{"version":3,"sources":["webpack:///./js/CountdownTimer.js","webpack:///./js/timers.js"],"names":["CountdownTimer","selector","targetDate","period","hideСlockFace","autoStart","ClockFaceSelectors","clockFace","clockFaceEnd","partSelectors","days","hours","mins","secs","this","_element","document","querySelector","_targetDate","_period","_hideСlockFace","_ClockFaceSelectors","_partSelectors","_timerId","_autoStart","differenceCurrentDate","time","Date","now","Math","floor","_updateHtml","differenceTime","partNodeRefs","DifTime","initialization","style","opacity","key","hasOwnProperty","innerHTML","String","padStart","_formNodeRef","Object","keys","reduce","acc","part","nodeRef","bind","startTimer","isActive","console","log","NodeRefs","setTimeout","repeatingFunc","differenceDate","DifTimeParts","stopTimer","clearInterval","constructor","val","Boolean"],"mappings":"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","file":"main.5317bb3a4c3daf5edff7.js","sourcesContent":["/*\r\n  CountdownTimer класс который позволяет создавать на странице таймер обратного отсчета.\r\n\r\n  пример вызова: \r\n  const options = {\r\n    //Обязательные параметры\r\n      selector: '#CDT', //CSS сектор узла внутри которого будет таймер\r\n      targetDate: new Date('01 01, 2021 00:00:00'), // Дата до которой ведем отсчет\r\n    \r\n    //Не обязательные параметры\r\n      period: 1000, //Частота с которой обновляем данные по умолчанию  1 сек\r\n      hideСlockFace: true, //Параметр который определяет будет ли по окончании отсчета прятаться табло и появляться надпись по умолчанию true\r\n      autoStart: false, //Параметр который отвечает за автоматический запуск таймера при создании класса\r\n    \r\n    //В следующих объектах передаются селекторы на обертки для элементов интерфейса часов и замещающей надписи\r\n    //Имена ключей менять нельзя. элементы должны находиться внутри узла переданного в selector\r\n      ClockFaceSelectors: {\r\n          clockFace: 'div.clock-face',\r\n          clockFaceEnd: 'div.clock-face-end',\r\n      },\r\n      partSelectors: {\r\n          days: '[data-value=\"days\"]',\r\n          hours: '[data-value=\"hours\"]',\r\n          mins: '[data-value=\"mins\"]',\r\n          secs: '[data-value=\"secs\"]',\r\n        },\r\n    };\r\n    const newYear = new CountdownTimer(options);\r\n\r\n  //Список методов для работы с CountdownTimer\r\n    newYear.startTimer(); //запускаем таймер\r\n    newYear.stopTimer(); //останавливаем таймер\r\n\r\n  //Статические методы\r\n    CountdownTimer.differenceCurrentDate(targetDate) //Вычисляет разницу между текущей датой и targetDate возвращает массив из двух элементов собственно разница в мс и объект с оставшимися днями часами минутами и секундами\r\n\r\n  //Набор гетеров для получения параметров\r\n    newYear.differenceDate //аналог differenceCurrentDate но возвращает разницу до даты указной при создании объекта\r\n    newYear.partSelectors //возвращает объект partSelectors\r\n    newYear.ClockFaceSelectors //возвращает объект ClockFaceSelectors\r\n    newYear.isActive //Возвращает текущее состояние таймера \r\n    newYear.period //Возвращает период обновления\r\n    newYear.hideСlockFace //Возвращает состояние параметра hideСlockFace\r\n    newYear.domNode //Возвращает ссылку на узел с таймером\r\n\r\n  //Набор сетеров для изменения параметров\r\n  //можно менять во время работы таймера\r\n  newYear.period = 5000 //принимает число милесикунд\r\n    newYear.hideСlockFace = true; //принимает любое значение которое можно привести к Boolean\r\n    newYear.targetDate = new Date('01 01, 2022 00:00:00') //принимает дату\r\n\r\n  //Можно менять только когда таймер остановлен\r\n    newYear.partSelectors = {days: '[data-value=\"today\"]', secs: '[data-value=\"tosec\"]'} //позволяет менять данные в объекте partSelectors\r\n    newYear.ClockFaceSelectors = {clockFace: 'span.clock-face'} //позволяет менять данные в объекте ClockFaceSelectors\r\n*/\r\n\r\n'use strict';\r\nexport default class CountdownTimer {\r\n  constructor({\r\n    selector,\r\n    targetDate,\r\n    period = 1000,\r\n    hideСlockFace = true,\r\n    autoStart = false,\r\n    ClockFaceSelectors = {\r\n      clockFace: 'div.clock-face',\r\n      clockFaceEnd: 'div.clock-face-end',\r\n    },\r\n    partSelectors = {\r\n      days: '[data-value=\"days\"]',\r\n      hours: '[data-value=\"hours\"]',\r\n      mins: '[data-value=\"mins\"]',\r\n      secs: '[data-value=\"secs\"]',\r\n    },\r\n  }) {\r\n    this._element = document.querySelector(selector);\r\n    this._targetDate = targetDate;\r\n    this._period = period;\r\n    this._hideСlockFace = hideСlockFace;\r\n    this._ClockFaceSelectors = ClockFaceSelectors;\r\n    this._partSelectors = partSelectors;\r\n    this._timerId = null;\r\n    this._autoStart(autoStart);\r\n  }\r\n  /*\r\n    Статический метод для подсчета разницы между целевой и текущей датой\r\n    принимает дату и возвращает массив состоящий из значения с разницей между датами\r\n    и объект с подсчитанной разницей.\r\n  */\r\n  static differenceCurrentDate(targetDate) {\r\n    const time = targetDate - Date.now();\r\n    return [\r\n      time,\r\n      {\r\n        days: Math.floor(time / (1000 * 60 * 60 * 24)),\r\n        hours: Math.floor((time % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60)),\r\n        mins: Math.floor((time % (1000 * 60 * 60)) / (1000 * 60)),\r\n        secs: Math.floor((time % (1000 * 60)) / 1000),\r\n      },\r\n    ];\r\n  }\r\n\r\n  /*\r\n    Набор гетеров для обращения из вне\r\n  */\r\n  get differenceDate() {\r\n    return this.constructor.differenceCurrentDate(this._targetDate);\r\n  }\r\n  get partSelectors() {\r\n    return { ...this._partSelectors };\r\n  }\r\n  get ClockFaceSelectors() {\r\n    return { ...this._ClockFaceSelectors };\r\n  }\r\n\r\n  get isActive() {\r\n    return this._timerId !== null;\r\n  }\r\n  get period() {\r\n    return this._period;\r\n  }\r\n  get hideСlockFace() {\r\n    return this._hideСlockFace;\r\n  }\r\n  get domNode() {\r\n    return this._element;\r\n  }\r\n\r\n  /*\r\n    Набор сетеров для изменения параметров\r\n  */\r\n  set period(val) {\r\n    this._period = val;\r\n  }\r\n  set hideСlockFace(val) {\r\n    this._hideСlockFace = Boolean(val);\r\n  }\r\n  set targetDate(val) {\r\n    this._targetDate = val;\r\n  }\r\n  set partSelectors(val) {\r\n    if (this.isActive) {\r\n      console.log('Нельзя изменить параметр partSelectors пока таймер активен');\r\n      return;\r\n    }\r\n    for (const key in this._partSelectors) {\r\n      this._partSelectors[key] = val[key];\r\n    }\r\n    console.log(this._partSelectors);\r\n  }\r\n  set ClockFaceSelectors(val) {\r\n    for (const key in this._ClockFaceSelectors) {\r\n      this._ClockFaceSelectors[key] = val[key];\r\n    }\r\n  }\r\n  /*\r\n    метод для обновления данных на странице\r\n    принимает объект со ссылками на узлы\r\n    и объект с данными по таким же ключам\r\n    разницу во времени между текущей и целевой датой\r\n    и параметр initialization устанавливаеваемый в true\r\n    при первом запуске для инициализации интерфейса\r\n  */\r\n  _updateHtml(differenceTime, partNodeRefs, DifTime, initialization) {\r\n    // При первом запуске выполняем инициализацию интерфейса\r\n    if (initialization) {\r\n      this._element.querySelector('.clock-face').style.opacity = 1;\r\n    }\r\n\r\n    // Проверяем наступление даты и в случае необходимости прячем\r\n    // интерфейс таймера за надпись заглушку\r\n    if (DifTime <= 0) {\r\n      const { clockFace, clockFaceEnd } = this._ClockFaceSelectors;\r\n      if (this._hideСlockFace) {\r\n        this._element.querySelector(clockFace).style.opacity = 0;\r\n        this._element.querySelector(clockFaceEnd).style.opacity = 1;\r\n      }\r\n      return;\r\n    }\r\n\r\n    // обновляем временные интервалы в интерфейсе\r\n    for (let key in partNodeRefs) {\r\n      if (partNodeRefs.hasOwnProperty(key)) {\r\n        partNodeRefs[key].innerHTML =\r\n          key !== 'days'\r\n            ? String(differenceTime[key]).padStart(2, '0')\r\n            : differenceTime[key];\r\n      }\r\n    }\r\n  }\r\n\r\n  /*\r\n    метод перебирает селекторы из объекта _partSelectors и возвращает\r\n    новый объект с найденыши нодами внутри узла _element \r\n  */\r\n  _formNodeRef() {\r\n    function formFunc(acc, part) {\r\n      const nodeRef = this._element.querySelector(this._partSelectors[part]);\r\n      if (nodeRef) {\r\n        acc[part] = nodeRef;\r\n        return acc;\r\n      }\r\n    }\r\n    return Object.keys(this._partSelectors).reduce(formFunc.bind(this), {});\r\n  }\r\n\r\n  /*\r\n    Метод для автоматического старта таймера\r\n  */\r\n  _autoStart(autoStart) {\r\n    if (autoStart) {\r\n      this.startTimer();\r\n    }\r\n  }\r\n\r\n  /*\r\n    метод для запуска таймера\r\n  */\r\n  startTimer() {\r\n    if (!this.isActive) {\r\n      const NodeRefs = this._formNodeRef();\r\n      function repeatingFunc(initialization = false) {\r\n        const [DifTime, DifTimeParts] = this.differenceDate;\r\n        this._updateHtml(DifTimeParts, NodeRefs, DifTime, initialization);\r\n        if (DifTime <= 0) {\r\n          this.stopTimer;\r\n          return;\r\n        }\r\n        this._timerId = setTimeout(repeatingFunc.bind(this), this.period);\r\n      }\r\n      this._timerId = setTimeout(repeatingFunc.bind(this), this.period, true);\r\n    } else {\r\n      console.log('Таймер уже запущен');\r\n    }\r\n  }\r\n\r\n  /*\r\n    метод для остановки таймера\r\n  */\r\n  stopTimer() {\r\n    if (this.isActive) {\r\n      clearInterval(this._timerId);\r\n      this._timerId = null;\r\n    } else {\r\n      console.log('Таймер еще не запущен');\r\n    }\r\n  }\r\n}\r\n","import CountdownTimer from './CountdownTimer';\r\n\r\nconst newYear = new CountdownTimer({\r\n  selector: '#new',\r\n  targetDate: new Date('01 01, 2021 00:00:00'),\r\n  autoStart: true,\r\n});\r\n\r\nconst old = new CountdownTimer({\r\n  selector: '#old',\r\n  targetDate: new Date('01 12, 2020 00:10:00'),\r\n  autoStart: true,\r\n});\r\n\r\nconst myGirlfriendBirthday = new CountdownTimer({\r\n  selector: '#my-girlfriends-birthday',\r\n  targetDate: new Date('11 30, 2020 00:00:00'),\r\n  autoStart: true,\r\n});\r\n"],"sourceRoot":""}